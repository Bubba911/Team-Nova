<?xml version="1.0" encoding="utf-8" ?><DEATHKNIGHT><Ability><Name>-- DoT Tracking --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-- DoT Reader
-- In a run once environment we shall create the Tooltip that we will be reading
-- all of the spell details from
if not nDoTTargets then
	nDoTTargets = {}
	nMetaTable = {
		dotDamage = 0,
		dotExpTime = 0,
		savedAP = 0,
	}

	local function cTarFinder(tarGUID)
		local cTar = {&amp;quot;target&amp;quot;, &amp;quot;mouseover&amp;quot;, &amp;quot;focus&amp;quot; }
		-- For Raid/Party Targets
		if IsInRaid() then
			i = 1
			while UnitExists(&amp;quot;raid&amp;quot;..i) do
				table.insert(cTar, &amp;quot;raid&amp;quot;..i)
				i=i+1
			end
		elseif IsInGroup() then
			i=1
			while UnitExists(&amp;quot;party&amp;quot;..i) do
				table.insert(cTar, &amp;quot;party&amp;quot;..i)
				i=i+1
			end
		end
		-- For Arena Targets
		if IsInInstance() and IsActiveBattlefieldArena() then
			for i=1, 5 do
				table.insert(cTar, &amp;quot;arena&amp;quot;..i)
				table.insert(cTar, &amp;quot;arenapet&amp;quot;..i)
			end
		end

		for i=1, #cTar do
			if UnitExists(cTar[i]) then
				if UnitGUID(cTar[i]) == tarGUID then
					return cTar[i]
				end
			end
		end

		return nil
	end

	nDotReader = CreateFrame( &amp;quot;GameTooltip&amp;quot;, &amp;quot;nDotTT&amp;quot;, nil, &amp;quot;GameTooltipTemplate&amp;quot; ); --Tooltip name cannot be nil
	nDotReader:SetOwner( WorldFrame, &amp;quot;ANCHOR_NONE&amp;quot; );
	-- Allow tooltip SetX() methods to dynamically add new lines based on these
	nDotReader:AddFontStrings(
		nDotReader:CreateFontString( &amp;quot;$parentTextLeft1&amp;quot;, nil, &amp;quot;GameTooltipText&amp;quot; ),
		nDotReader:CreateFontString( &amp;quot;$parentTextRight1&amp;quot;, nil, &amp;quot;GameTooltipText&amp;quot; ) );
	nDoTCheck = nil
	function nDoTCheck(spellID, tar)
		if GetCVar(&amp;quot;DotDamage&amp;quot;) == nil then
			RegisterCVar(&amp;quot;DotDamage&amp;quot;, 0)
		end
		nDotReader:ClearLines()
		local i = 1
		while UnitDebuff(tar, i) do
			if UnitDebuff(tar, i) == GetSpellInfo(spellID) then
				nDotReader:SetUnitDebuff(tar, i)
				scanText = _G[&amp;quot;nDotTTTextLeft2&amp;quot;]:GetText()
				local DoTDamage = scanText:match(&amp;quot;([0-9]+%.?[0-9]*)&amp;quot;)
				SetCVar(&amp;quot;DotDamage&amp;quot;, tonumber(DoTDamage))
				return tonumber(GetCVar(&amp;quot;DotDamage&amp;quot;)), select(7, UnitDebuff(tar, i))
			end
			i=i+1
		end

		return 0, 0
	end

	-- DoT Tracker
	nDoTTracker = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;nDoTTracker&amp;quot;)
	nDoTTracker:RegisterEvent(&amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot;)
	nDoTTracker:RegisterEvent(&amp;quot;PLAYER_REGEN_ENABLED&amp;quot;)
	nDoTTracker:SetScript(&amp;quot;OnEvent&amp;quot;, function(_, event, ...)
		local arg = {...}
		if event == &amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot; then
			if arg[4] == UnitGUID(&amp;quot;player&amp;quot;) then

				-- This is for when we first apply the Debuff to the Target

				if arg[2] == &amp;quot;SPELL_AURA_APPLIED&amp;quot; or arg[2] == &amp;quot;SPELL_PERIODIC_AURA_APPLIED&amp;quot; then
					if arg[12] == 55095 or arg[12] == 55078 then
						local shGUID = string.sub(tostring(arg[8]), -5, -1)
						local cTar = cTarFinder(arg[8])
						if cTar then
							local dotDamage, expTime = nDoTCheck(arg[12], cTar)
							if not nDoTTargets[shGUID] then nDoTTargets[shGUID] = { guid = arg[8] } end --setmetatable(nDoTTargets[shGUID][tostring(arg[12])], nMetaTable) end
							nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
						else
							if not nDoTTargets[shGUID] then nDoTTargets[shGUID] = { guid = arg[8] } end
							nDoTTargets[shGUID][arg[12]] = { dotDamage = 0, dotExpTime = 0, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;)}
						end
					end

					-- This is for when the Debuff is Removed from the Target

				elseif arg[2] == &amp;quot;SPELL_AURA_REMOVED&amp;quot; or arg[2] == &amp;quot;SPELL_PERIODIC_AURA_REMOVED&amp;quot; then
					if arg[12] == 55095 or arg[12] == 55078 then
						local shGUID = string.sub(tostring(arg[8]), -5, -1)
						if nDoTTargets[shGUID] then
							nDoTTargets[shGUID][arg[12]] = nil
						end
					end

					-- This is for when we change targets and on a Tick, it will refresh the dotDamage is it wasn&amp;apos;t there before

				elseif arg[2] == &amp;quot;SPELL_AURA_DAMAGE&amp;quot; or arg[2] == &amp;quot;SPELL_PERIODIC_DAMAGE&amp;quot; then
					if arg[12] == 55095 or arg[12] == 55078 then
						local shGUID = string.sub(tostring(arg[8]), -5, -1)
						if nDoTTargets[shGUID] then
							if nDoTTargets[shGUID][arg[12]] then
								if nDoTTargets[shGUID][arg[12]].dotDamage == 0 then
									local cTar = cTarFinder(arg[8])
									if cTar then
										local dotDamage, expTime = nDoTCheck(arg[12], cTar)
										nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = nDoTTargets[shGUID][arg[12]].savedAP  }
									end
								end
							else
								local cTar = cTarFinder(arg[8])
								if cTar then
									local dotDamage, expTime = nDoTCheck(arg[12], cTar)
									nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;)  }
								else
									nDoTTargets[shGUID][arg[12]] = { dotDamage = 0, dotExpTime = 0, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;)  }
								end
							end
						else
							local cTar = cTarFinder(arg[8])
							if not nDoTTargets[shGUID] then nDoTTargets[shGUID] = { guid = arg[8] } end
							if cTar then
								local dotDamage, expTime = nDoTCheck(arg[12], cTar)
								nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							else
								nDoTTargets[shGUID][arg[12]] = { dotDamage = 0, dotExpTime = 0, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							end
						end
					end

					-- This is for when we Reapply the Debuff to the Target (before it is removed)

				elseif arg[2] == &amp;quot;SPELL_AURA_REFRESH&amp;quot; or arg[2] == &amp;quot;SPELL_PERIODIC_AURA_REFRESH&amp;quot; then
					if arg[12] == 55095 or arg[12] == 55078 then
						local shGUID = string.sub(tostring(arg[8]), -5, -1)
						if nDoTTargets[shGUID] then
							local cTar = cTarFinder(arg[8])
							if cTar then
								local dotDamage, expTime = nDoTCheck(arg[12], cTar)
								nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							else
								nDoTTargets[shGUID][arg[12]] = { dotDamage = 0, dotExpTime = 0, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							end
						else
							local cTar = cTarFinder(arg[8])
							if not nDoTTargets[shGUID] then nDoTTargets[shGUID] = { guid = arg[8] } end
							if cTar then
								local dotDamage, expTime = nDoTCheck(arg[12], cTar)
								nDoTTargets[shGUID][arg[12]] = { dotDamage = dotDamage, dotExpTime = expTime, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							else
								nDoTTargets[shGUID][arg[12]] = { dotDamage = 0, dotExpTime = 0, savedAP = UnitAttackPower(&amp;quot;player&amp;quot;) }
							end
						end
					end
				end
			end
		elseif event == &amp;quot;PLAYER_REGEN_ENABLED&amp;quot; then
			table.wipe(nDoTTargets)
		end
	end)
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Debuff Handling</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>local FF,_,_,_,_,_,FFtimer = UnitDebuffID(PQR_CustomTarget,55095,&amp;quot;player&amp;quot;)
local BP,_,_,_,_,_,BPtimer = UnitDebuffID(PQR_CustomTarget,55078,&amp;quot;player&amp;quot;)

if IsSpellKnown(77575)
	and PQ_ValidUnit
	and IsSpellInRange(GetSpellInfo(77575),PQR_CustomTarget) == 1
then
	-- If Outbreak is on Cooldown we&amp;apos;ll check if the diseases are up.
	if GetSpellCooldown(77575) ~= 0 then
		if FF then
			-- If less than 3 seconds left on Frost Fever, reapply is Outbreak is down.
			if FFtimer - GetTime() &amp;lt; 3 then
				CastSpellByID(45477,PQR_CustomTarget)
			end
		-- If Frost Fever isn&amp;apos;t on Target, apply with Icey Touch if Outbreak is down.
		else CastSpellByID(45477,PQR_CustomTarget) end
		
		if BP then
			-- If less than 3 seconds left on Blood Plague, reapply is Outbreak is down.
			if BPtimer - GetTime() &amp;lt; 3 then
				CastSpellByID(45462,PQR_CustomTarget)
			end
		-- If Blood Plague isn&amp;apos;t on Target, apply with Icey Touch if Outbreak is down.
		else CastSpellByID(45462,PQR_CustomTarget) end
	else
		-- If Outbreak is off Cooldown, and either FF or BP isn&amp;apos;t on target, cast Outbreak
		if not FF or not BP then
			CastSpellByID(77575,PQR_CustomTarget)
		else
			-- If both Diseases are on, but either one has less than 3 seconds remaining, Cast Outbreak.
			if (FF and FFtimer - GetTime() &amp;lt; 3) or (BP and BPtimer - GetTime() &amp;lt; 3)
			then CastSpellByID(77575,PQR_CustomTarget) end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Init --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-------------------------------------------------------------------------------
-- Variables &amp; Sanity checks
-------------------------------------------------------------------------------
if PQR_RotationStarted then
	PQR_RotationStarted = false
	
	-- Load LUA Data Files
	if PQR_LoadLua ~= nil then
		-- Load the data
		if PQR_LoadLua(&amp;quot;PQR_Nova_Data.lua&amp;quot;) == false then
			PQR_WriteToChat(&amp;quot;|cffFFCCFFYou&amp;apos;re missing PQR_Nova_Data.lua - Make sure it&amp;apos;s in your Data folder! The Rotation has been halted.|cffffffff&amp;quot;, &amp;quot;Error&amp;quot;)
			PQR_StopRotation()
			return true
		end
	end
end

NUI = Nova_UnitInfo

--Halt the entire profile if we&amp;apos;re not in a usable spec!
if not CastTimer then CastTimer = GetTime() end
if PQR_Spec == 1 then CurSpec = &amp;quot;Blood&amp;quot; elseif PQR_Spec == 2 then CurSpec = &amp;quot;Frost&amp;quot; end

if PQR_Spec ~= 3 then
	if GetTime() - CastTimer &amp;gt;= 4 then
		PQR_WriteToChat(&amp;quot;|cff99CCFFYou&amp;apos;re currently specced: |cffFFCCFF&amp;quot;..CurSpec..&amp;quot;|cff99CCFF! You need to be Unholy!&amp;quot;, &amp;quot;Error&amp;quot;)
		CastTimer = GetTime()
	end
end

-- Let them know everything worked out fine!
if not PQR_UHDKLoaded then
	PQR_UHDKLoaded = true
	PQR_WriteToChat(&amp;quot;|cff99CCFFNova - |cffc5bfb3Unholy |cffC41F3BDeath Knight|cff99CCFF Rotation is |cffFFCCFFLoaded!|cffffffff&amp;quot;)
end


-------------------------------------------------
-- Start of Run Once
-------------------------------------------------



-- Variables
PQR_ResetMovementTime = 0.3
PQR_SpellAvailableTime = ((select(3,GetNetStats()) + select(4,GetNetStats())) / 1000)
-------------------
-- PQI Setup
-------------------

if not PQI_Setup_Unholy then
	PQI_Unholy_DK = {
		name = &amp;apos;Arena UH DK&amp;apos;,
		author = &amp;apos;Nova&amp;apos;,
		abilities = {
			{name = &amp;apos;Lichborne Heal&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 80,
				step = 1,
				},
			},
			{name = &amp;apos;Lichborne Heal Pet&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 40,
				step = 1,
				},
			},
			{name = &amp;apos;Summon Gargoyle&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 30,
				step = 1,
				},
			},
			
			{name = &amp;apos;Empower Rune Weapon&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 30,
				step = 1,
				},
			},
			{name = &amp;apos;Unholy Frenzy&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 30,
				step = 1,
				},
			},
			{name = &amp;apos;Enter BG Wait Time&amp;apos;,
				enable = true,
				tooltip = &amp;apos;This is how long it will take to click Enter Battleground Button&amp;apos;,
				widget = {
					type = &amp;apos;numbox&amp;apos;,
					value = 10,
					step = 1,
					min = 1,
					max = 20,
				},
			},
		},
		hotkeys = {
			{name = &amp;apos;Pause&amp;apos;,
			enable = true,
			tooltip = &amp;quot;Pauses the rotation, allowing you to click/cast something yourself!&amp;quot;,
			hotkeys = {&amp;apos;la&amp;apos;},
			},
			{name = &amp;apos;Blood Boil&amp;apos;,
			enable = true,
			tooltip = &amp;quot;Will cast Blood Boil (Good for Rolling Blood!)&amp;quot;,
			hotkeys = {&amp;apos;ls&amp;apos;},
			},
			{name = &amp;apos;Death Grip&amp;apos;,
			enable = true,
			tooltip = &amp;quot;Death grip mouseover target&amp;quot;,
			hotkeys = {&amp;apos;lc&amp;apos;},
			},
			{name = &amp;apos;BurnSwitch&amp;apos;,
			enable = true,
			tooltip = &amp;quot;Not yet implemented&amp;quot;,
			hotkeys = {&amp;apos;rs&amp;apos;},
			},
		}
	}
	
	PQI_Setup_Unholy = PQI:AddRotation(PQI_Unholy_DK)
end


function PQI_Setup_Variables(tableName, Prefix) -- Name of the PQI Table, [Prefix you want to affix to Variable (Nova is default if left blank)]
	local tableName = tableName
	local Prefix = Prefix or &amp;quot;Nova&amp;quot;
	if type(Prefix) ~= &amp;quot;string&amp;quot; then
		Prefix = &amp;quot;Nova&amp;quot;
	end
	local PQI_String = string.format(&amp;quot;%s_%s%s&amp;quot;, &amp;quot;PQI&amp;quot;, gsub(tableName.author, &amp;quot;%s&amp;quot;, &amp;quot;&amp;quot;), gsub(tableName.name, &amp;quot;%s&amp;quot;, &amp;quot;&amp;quot;))
	if type(tableName.abilities) == &amp;quot;table&amp;quot; then
		for i=1, #tableName.abilities do
			local AbilitiesName = gsub(tableName.abilities[i].name, &amp;apos;%s&amp;apos;, &amp;apos;&amp;apos;)
			local Variable = string.format(&amp;apos;%s_%s&amp;apos;, Prefix, AbilitiesName)
			local PQI_String_Enable = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, AbilitiesName, &amp;quot;enable&amp;quot;)
			local PQI_String_Value = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, AbilitiesName, &amp;quot;value&amp;quot;)
			
			if _G[PQI_String_Enable] ~= nil then -- This is to verify that PQI is fully loaded before trying to make the Variables
				_G[Variable..&amp;apos;_Check&amp;apos;] = _G[tostring(PQI_String_Enable)] -- Output = Prefix_AbilityName_Check
				_G[Variable] = _G[tostring(PQI_String_Value)] -- Output = Prefix_AbilityName
			else
				return false
			end
		end
	end
	if type(tableName.hotkeys) == &amp;quot;table&amp;quot; then
		for h=1, #tableName.hotkeys do
			local HotkeyName = gsub(tableName.hotkeys[h].name, &amp;apos;%s&amp;apos;, &amp;apos;&amp;apos;)
			local Variable = string.format(&amp;apos;%s_%s%s&amp;apos;, Prefix, &amp;quot;Mod&amp;quot;, HotkeyName)
			local PQI_String_Enable = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, HotkeyName, &amp;quot;enable&amp;quot;)
			local PQI_String_Key = string.format(&amp;apos;%s_%s_%s&amp;apos;, PQI_String, HotkeyName, &amp;quot;key&amp;quot;)
			
			if _G[PQI_String_Key] ~= nil then
				_G[Variable..&amp;apos;_Check&amp;apos;] = _G[tostring(PQI_String_Enable)] -- Output = Prefix_ModAbilityName_Check
				_G[Variable] = PQI:IsHotkeys(_G[PQI_String_Key]) -- Output = Prefix_ModAbilityName_Key
			else
				return false
			end
		end
	end

	return true
end





-------------------------------------------------------------------------------
-- Misc. Functions
-------------------------------------------------------------------------------
if not enterBG then
	local enterBG = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;enterBG&amp;quot;)
	enterBG:RegisterEvent(&amp;quot;PLAYER_ENTERING_BATTLEGROUND&amp;quot;)
	enterBG:SetScript(&amp;quot;OnEvent&amp;quot;, function(self, event, ...)
		if event == &amp;quot;PLAYER_ENTERING_BATTLEGROUND&amp;quot; then AlreadyJoined = false end
	end)
end


-- Death Rune on CD Check
DeathRuneCD = nil
function DeathRuneCD()
	local DRunesOnCD = 0
	local DRunesOffCD = 0
	for i=1, 4 do
		if GetRuneType(i) == 4 and select(3, GetRuneCooldown(i)) == false then
			DRunesOnCD = DRunesOnCD + 1
		elseif GetRuneType(i) == 4 and select(3, GetRuneCooldown(i)) == true then
			DRunesOffCD = DRunesOffCD + 1
		end
	end
	
	return DRunesOnCD, DRunesOffCD
end

-- Death Rune checker.
DeathRuneCheck = nil
function DeathRuneCheck()
	local numDeathRunes = 0
	for i=1, 6 do
		if GetRuneType(i) == 4 then
			numDeathRunes = numDeathRunes + 1
		end
	end
	
	return numDeathRunes
end

-- Normal Rune Check
RuneCheck = nil
function RuneCheck()
	local nRuneTable = {0,0,0,0}
	for i=1, 6 do
		if select(3, GetRuneCooldown(i)) == true then
			nRuneTable[GetRuneType(i)] = nRuneTable[GetRuneType(i)] + 1
		end
	end
	
	return nRuneTable[1], nRuneTable[2], nRuneTable[3], nRuneTable[4]
end

--Depleted Rune Check
DepletedRune = nil
function DepletedRune()
	local total = 0
	if select(3, GetRuneCooldown(1)) == false and select(3, GetRuneCooldown(2)) == false then
		total = total + 1
	end
	if select(3, GetRuneCooldown(3)) == false and select(3, GetRuneCooldown(4)) == false then
		total = total + 1
	end
	if select(3, GetRuneCooldown(5)) == false and select(3, GetRuneCooldown(6)) == false then
		total = total + 1
	end

	return total
end

CalcDoT = nil
function CalcDoT(string)
	local baseDMG = string == &amp;quot;shadow&amp;quot; and 210.5 or 226
	local apPerc = string == &amp;quot;shadow&amp;quot; and .256 or .251
	local apAmount = UnitAttackPower(&amp;quot;player&amp;quot;)
	local masteryAmount = string == &amp;quot;shadow&amp;quot; and 1+(GetMasteryEffect()/100) or 1
	local calc = (226 + (apPerc * apAmount)) *  masteryAmount

	return calc
end

nSmartDoT = nil
function nSmartDoT(spellID)
	local shGUID = string.sub(tostring(UnitGUID(&amp;quot;target&amp;quot;)), -5, -1)
	if nDoTTargets[shGUID] then
		if nDoTTargets[shGUID][spellID] then
			if nDoTTargets[shGUID][spellID].dotDamage &amp;gt; 0 then
				local nBloodPlague = CalcDoT(&amp;quot;shadow&amp;quot;)
				if nBloodPlague &amp;gt; nDoTTargets[shGUID][spellID].dotDamage then
					if (math.abs(nBloodPlague-nDoTTargets[shGUID][spellID].dotDamage)) / nBloodPlague &amp;gt;= .10 then
						return true
					end
				end
			elseif UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt; nDoTTargets[shGUID][spellID].savedAP then
				if (math.abs(UnitAttackPower(&amp;quot;player&amp;quot;) - nDoTTargets[shGUID][spellID].savedAP)) / UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt;= .10 then
					return true
				end
			end
		else 
			return true
		end
	else
		return true
	end
	
	return false
end

nDoT=nil
function nDoT(spellID)
	local shGUID = string.sub(tostring(UnitGUID(&amp;quot;target&amp;quot;)), -5, -1)
	if nDoTTargets[shGUID] then
		if nDoTTargets[shGUID][spellID] then
			if nDoTTargets[shGUID][spellID].dotExpTime - GetTime() &amp;lt;= 3 then
				return true
			else
				return false
			end
		else 
			return true
		end
	else
		return true
	end
	
	return false
end

NoImmunity = nil
function NoImmunity(tar)
	local ImmunityList = { }
	for i=1, #ImmunityList do
		if UnitDebuff(tar, GetSpellInfo(ImmunityList[i])) then
			return false
		end
	end

	return true
end

nUnitFacing = false



--------------------------------------------------
-- End of Run Once
--------------------------------------------------

if not EnterBGTimer then EnterBGTimer = 0; AlreadyJoined = false end
local acceptQueue=GetBattlefieldStatus(1)
if acceptQueue == &amp;quot;confirm&amp;quot; and not AlreadyJoined and Nova_EnterBGWaitTime_Check then
	AlreadyJoined = true
	EnterBGTimer = GetTime()
end

if AlreadyJoined and EnterBGTimer &amp;gt; 0 then
	if GetTime() - EnterBGTimer &amp;gt;= Nova_EnterBGWaitTime and Nova_EnterBGWaitTime_Check then
		EnterBGTimer = 0
		AcceptBattlefieldPort(1,1)
	end
end


-- Target validation.
if UnitExists(&amp;quot;target&amp;quot;)
	and (UnitIsEnemy(&amp;quot;player&amp;quot;, &amp;quot;target&amp;quot;) or UnitCanAttack(&amp;quot;player&amp;quot;, &amp;quot;target&amp;quot;))
	and (not UnitIsDeadOrGhost(&amp;quot;target&amp;quot;) and not UnitIsCorpse(&amp;quot;target&amp;quot;))
	and not PQR_IsOutOfSight(&amp;quot;target&amp;quot;) and NoImmunity(&amp;quot;target&amp;quot;)
then
	PQ_ValidUnit = true
	nUnitFacing = PQR_UnitFacing(&amp;quot;player&amp;quot;, &amp;quot;target&amp;quot;)
	PQR_CustomTarget = &amp;quot;target&amp;quot;
end

if not PetDelayTimer then PetDelayTimer = GetTime() end
if not PQI_Setup_Variables(PQI_Unholy_DK, &amp;quot;Nova&amp;quot;) 
 or (Nova_ModPause
 and Nova_ModPause_Check)
 or UnitIsDeadOrGhost(&amp;quot;player&amp;quot;)
 or IsMounted() then
 	PetDelayTimer = GetTime()
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Plague Strike</Name><Default>false</Default><SpellID>45462</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(45462)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	if nDoT(55078) then
		if Nova_CheckLastCast(3, 0.5) then
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Festering Strike</Name><Default>false</Default><SpellID>85948</SpellID><Actions></Actions><Lua>local drCD, drCheck = { DeathRuneCD() }, { DeathRuneCheck() }

if PQR_SpellAvailable(85948)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	if drCD[2] &amp;lt; 2 then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Chains of Ice</Name><Default>false</Default><SpellID>45524</SpellID><Actions></Actions><Lua>local chains = { UnitDebuffID(&amp;quot;target&amp;quot;, 45524) }
if PQR_SpellAvailable(45524)
 and PQ_ValidUnit
 and not chains[1]
 and IsSpellInRange(GetSpellInfo(45524), PQR_CustomTarget) == 1
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 0
 and PQR_IsMoving(1) then
	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Scourge Strike</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if ( select(2, RuneCheck()) &amp;gt; 0 or select(4, RuneCheck()) &amp;gt; 0 )
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	CastSpellByName(GetSpellInfo(55090), PQR_CustomTarget)
	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Strike</Name><Default>false</Default><SpellID>49998</SpellID><Actions></Actions><Lua>return true</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Soul Reaper</Name><Default>false</Default><SpellID>130736</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(130736)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(130736), PQR_CustomTarget) == 1 then 	
	local targetHealth = 100 * UnitHealth(PQR_CustomTarget) / UnitHealthMax(PQR_CustomTarget)
	if targetHealth &amp;lt;= 30 then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Raise Dead</Name><Default>false</Default><SpellID>46584</SpellID><Actions></Actions><Lua>if not UnitExists(&amp;quot;pet&amp;quot;) and GetTime() - PetDelayTimer &amp;gt;= 2 then
	if PQR_SpellAvailable(46584) then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Outbreak</Name><Default>false</Default><SpellID>77575</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(77575)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(77575), PQR_CustomTarget) == 1 then
	if nDoT(55095) then
		if Nova_CheckLastCast(3, 0.5) then
			return true
		end
	elseif nDoT(55078) then
		if Nova_CheckLastCast(3, 0.5) then
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Mind Freeze</Name><Default>false</Default><SpellID>47528</SpellID><Actions></Actions><Lua>return true</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Necrotic Strike</Name><Default>false</Default><SpellID>73975</SpellID><Actions></Actions><Lua>local NecroStrike = { UnitDebuff(PQR_CustomTarget, GetSpellInfo(73975), &amp;quot;PLAYER&amp;quot;) }

if select(4, RuneCheck()) &amp;gt; 0
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
 	if NecroStrike[1] then
 		if NecroStrike[15] &amp;gt;= 100000 then
 			if NecroStrike[7] - GetTime() &amp;lt;= 2 then
 				return true
 			else
				return false
			end
		else
			return true
		end
	else
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Plague Leech</Name><Default>false</Default><SpellID>123693</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(123693) then
	if PQ_ValidUnit
	 and IsSpellInRange(GetSpellInfo(123693), PQR_CustomTarget) == 1 then
	 	if UnitDebuff(PQR_CustomTarget, GetSpellInfo(55095)) 
	 	 and UnitDebuff(PQR_CustomTarget, GetSpellInfo(55078)) then
	 	 	if PQR_SpellAvailable(77575) then	
		 	 	if DepletedRune() &amp;gt;= 2 then
		 	 		return true
		 	 	end
			end
		end
	elseif UnitExists(&amp;quot;focus&amp;quot;)
	 and IsSpellInRange(GetSpellInfo(123693), &amp;quot;focus&amp;quot;) == 1 then
	 	if UnitDebuff(&amp;quot;focus&amp;quot;, GetSpellInfo(55095)) 
	 	 and UnitDebuff(&amp;quot;focus&amp;quot;, GetSpellInfo(55078)) then
	 	 	if DepletedRune() &amp;gt;= 2 then
	 	 		return true
	 	 	end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Dark Transformation</Name><Default>false</Default><SpellID>63560</SpellID><Actions></Actions><Lua>local DT = { UnitBuffID(&amp;quot;player&amp;quot;, 91342) }
if UnitExists(&amp;quot;pet&amp;quot;)
 and not UnitIsDead(&amp;quot;pet&amp;quot;) then
	if DT[1] then
		if DT[4] &amp;gt;= 5 then
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Pet</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Anti-Magic Shell</Name><Default>false</Default><SpellID>48707</SpellID><Actions></Actions><Lua>return false</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Icebound Fortitude</Name><Default>false</Default><SpellID>48792</SpellID><Actions></Actions><Lua>return true</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Coil (Off)</Name><Default>false</Default><SpellID>47541</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(47541)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(47541), PQR_CustomTarget) == 1
 and select(4, NUI(&amp;quot;player&amp;quot;)) &amp;gt;= 32 then
 	local DT = { UnitBuff(&amp;quot;pet&amp;quot;, GetSpellInfo(63560)) }
 	if DT[1] then
 		if DT[7] - GetTime() &amp;lt; 10 then
 			if select(4, NUI(&amp;quot;player&amp;quot;)) &amp;gt;= 100 then
 				return true
 			else
 				return false
 			end
 		else
 			return true
 		end
 	else
 		return true
 	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Coil (Def)</Name><Default>false</Default><SpellID>47541</SpellID><Actions></Actions><Lua>local Lichborne = { UnitBuff(&amp;quot;player&amp;quot;, GetSpellInfo(49039)) }

if Lichborne[1] then
	if select(4, NUI(&amp;quot;player&amp;quot;)) &amp;gt;= 32 and NUI(&amp;quot;player&amp;quot;) &amp;lt;= Nova_LichborneHeal then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Horn of Winter</Name><Default>false</Default><SpellID>57330</SpellID><Actions></Actions><Lua>if UnitAffectingCombat(&amp;quot;player&amp;quot;) then
	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Empower Rune Weapon</Name><Default>false</Default><SpellID>47568</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(49206) 
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45524), PQR_CustomTarget) == 1 then
	local targetHealth = 100 * UnitHealth(PQR_CustomTarget) / UnitHealthMax(PQR_CustomTarget)
	
	if targetHealth &amp;lt;= Nova_EmpowerRuneWeapon and Nova_EmpowerRuneWeapon_Check then
		local runeCheck = { RuneCheck() }
		local total = 0
		for i=1, #runeCheck do
			total = runeCheck[i] + total
		end
		
		if total &amp;lt; 2 then
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Strangulate</Name><Default>false</Default><SpellID>47476</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable()
 and UnitExists(&amp;quot;focus&amp;quot;)
 and IsSpellInRange(GetSpellInfo(), &amp;quot;focus&amp;quot;) == 1 then
 	if GetCastingInfo(&amp;quot;focus&amp;quot;) then
 		return true
 	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Summon Gargoyle</Name><Default>false</Default><SpellID>49206</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(49206) 
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45524), PQR_CustomTarget) == 1 then
	local targetHealth = 100 * UnitHealth(PQR_CustomTarget) / UnitHealthMax(PQR_CustomTarget)
	
	if targetHealth &amp;lt;= Nova_SummonGargoyle and Nova_SummonGargoyle_Check then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Unholy Frenzy</Name><Default>false</Default><SpellID>49016</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(49206) 
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45524), PQR_CustomTarget) == 1 then
	local targetHealth = 100 * UnitHealth(PQR_CustomTarget) / UnitHealthMax(PQR_CustomTarget)
	
	if targetHealth &amp;lt;= Nova_UnholyFrenzy and Nova_UnholyFrenzy_Check then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Blood Tap</Name><Default>false</Default><SpellID>45529</SpellID><Actions></Actions><Lua>local bloodTap = { UnitBuff(&amp;quot;player&amp;quot;, GetSpellInfo(114851)) }
if bloodTap[1] then
	if bloodTap[4] &amp;gt;= 11 then
		if DepletedRune() &amp;gt;= 1 then
			if Nova_CheckLastCast(1, 0.5) then
				return true
			end
		end
	end
end</Lua><RecastDelay>500</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Dark Simulacrum</Name><Default>false</Default><SpellID>77606</SpellID><Actions></Actions><Lua>return true</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Festering Strike (Dis)</Name><Default>false</Default><SpellID>85948</SpellID><Actions></Actions><Lua>local DiseaseList = {
	55095, -- Frost Fever
	55078, -- Blood Plague
	45524, -- Chains of Ice
}

if PQR_SpellAvailable(85948)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	for i=1, #DiseaseList do
		local diseaseCheck = { UnitDebuff(PQR_CustomTarget, GetSpellInfo(DiseaseList[i])) }
		if diseaseCheck[1] then
			if diseaseCheck[11] == 45524 then
				if diseaseCheck[7] - GetTime() &amp;lt; 2 then
					return true
				end
			else
				if diseaseCheck[7] - GetTime() &amp;lt; 6 then
					return true
				end
			end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Coil (Proc)</Name><Default>false</Default><SpellID>47541</SpellID><Actions></Actions><Lua>local SD = { UnitBuff(&amp;quot;player&amp;quot;, GetSpellInfo(81340)) }
local DT = { UnitBuff(&amp;quot;pet&amp;quot;, GetSpellInfo(91342)) }

if PQR_SpellAvailable(47541)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(47541), PQR_CustomTarget) == 1 then
	if SD[1] then
		if DT[1] then
			local DTleft = DT[7] - GetTime()
			if DTleft &amp;lt; 5 and SD[7] - GetTime() - DTleft &amp;gt;= 2 then
				return false
			end
		end
		
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Necrotic Strike (LowHP)</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	local targetHealth = 100 * UnitHealth(PQR_CustomTarget) / UnitHealthMax(PQR_CustomTarget)
	if targetHealth &amp;lt;= 35 and UnitDebuff(PQR_CustomTarget, GetSpellInfo(130736), &amp;quot;PLAYER&amp;quot;) then
		if select(4, RuneCheck()) == 0 then			
			local BT = { UnitBuff(&amp;quot;player&amp;quot;, GetSpellInfo(114851)) }
			if BT[1] then
				if BT[4] &amp;gt;= 5 then
					CastSpellByName(GetSpellInfo(45529), &amp;quot;player&amp;quot;)
					return true
				end
			end
		else
			CastSpellByName(GetSpellInfo(73975), PQR_CustomTarget)
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Plague Strike - Old</Name><Default>false</Default><SpellID>45462</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(45462)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	local shGUID = string.sub(tostring(UnitGUID(&amp;quot;target&amp;quot;)), -5, -1)
	if nDoTTargets[shGUID] then
		if nDoTTargets[shGUID][55078] then
			if nDoTTargets[shGUID][55078].dotDamage &amp;gt; 0 then
				local nBloodPlague = CalcDoT(&amp;quot;shadow&amp;quot;)
				if nBloodPlague &amp;gt; nDoTTargets[shGUID][55078].dotDamage then
					if (math.abs(nBloodPlague-nDoTTargets[shGUID][55078].dotDamage)) / nBloodPlague &amp;gt;= .10 then
						return true
					end
				end
			elseif UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt; nDoTTargets[shGUID][55078].savedAP then
				if (math.abs(UnitAttackPower(&amp;quot;player&amp;quot;) - nDoTTargets[shGUID][55078].savedAP)) / UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt;= .10 then
					return true
				end
			end
		else 
			return true
		end
		if nDoTTargets[shGUID][55095] then
			if nDoTTargets[shGUID][55095].dotDamage &amp;gt; 0 then
				local nBloodPlague = CalcDoT()
				if nBloodPlague &amp;gt; nDoTTargets[shGUID][55095].dotDamage then
					if (math.abs(nBloodPlague-nDoTTargets[shGUID][55095].dotDamage)) / nBloodPlague &amp;gt;= .10 then
						return true
					end
				end
			elseif UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt; nDoTTargets[shGUID][55095].savedAP then
				if (math.abs(UnitAttackPower(&amp;quot;player&amp;quot;) - nDoTTargets[shGUID][55095].savedAP)) / UnitAttackPower(&amp;quot;player&amp;quot;) &amp;gt;= .10 then
					return true
				end
			end
		else
			return true
		end
	else
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Plague Strike - PvE</Name><Default>false</Default><SpellID>45462</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(45462)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	if nSmartDoT(55098) then
		return true
	elseif nSmartDoT(55078) then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Outbreak - PvE</Name><Default>false</Default><SpellID>77575</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(77575)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(77575), PQR_CustomTarget) == 1 then
	if nSmartDoT(77575) then
		return true
	elseif nSmartDoT(77575) then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Click</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Asphyxiate</Name><Default>false</Default><SpellID>109194</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(108194)
 and UnitExists(&amp;quot;focus&amp;quot;)
 and IsSpellInRange(GetSpellInfo(108194), &amp;quot;focus&amp;quot;) == 1 then
 	if GetCastingInfo(&amp;quot;focus&amp;quot;) then
 		return true
 	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Grip</Name><Default>false</Default><SpellID>49576</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(49576)
 and Nova_ModDeathGrip
 and Nova_ModDeathGrip_Check
 and UnitExists(&amp;quot;mouseover&amp;quot;)
 and UnitCanAttack(&amp;quot;player&amp;quot;, &amp;quot;mouseover&amp;quot;)
 and IsSpellInRange(GetSpellInfo(49576), &amp;quot;mouseover&amp;quot;) == 1 then
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Mouseover</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Blood Boil</Name><Default>false</Default><SpellID>48721</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(48721)
 and Nova_ModBloodBoil
 and Nova_ModBloodBoil_Check
 and not GetCurrentKeyBoardFocus()
 and PQ_ValidUnit then
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Blood Strike</Name><Default>false</Default><SpellID>45902</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(45902)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45902), PQR_CustomTarget) == 1 then
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Auto Focus Heal (Arena)</Name><Default>false</Default><SpellID>48721</SpellID><Actions></Actions><Lua>return false</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Death Coil (Pet)</Name><Default>false</Default><SpellID>47541</SpellID><Actions></Actions><Lua>if UnitExists(&amp;quot;pet&amp;quot;)
 and not UnitIsDead(&amp;quot;pet&amp;quot;) then
	if select(4, NUI(&amp;quot;player&amp;quot;)) &amp;gt;= 32 
	 and NUI(&amp;quot;pet&amp;quot;) &amp;lt;= Nova_LichborneHealPet 
	 and IsSpellInRange(GetSpellInfo(47541), &amp;quot;pet&amp;quot;) == 1 then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Pet</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Festering Strike - Old</Name><Default>false</Default><SpellID>85948</SpellID><Actions></Actions><Lua>local drCD, drCheck = { DeathRuneCD() }, { DeathRuneCheck() }

if PQR_SpellAvailable(85948)
 and PQ_ValidUnit
 and IsSpellInRange(GetSpellInfo(45462), PQR_CustomTarget) == 1 then
	if drCD[2] &amp;lt; 2 then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Spell Queue --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-- I am going to create a simple frame that will accept either SPELL ID input, or SPELL NAME input...
-- I will try and distinguish which is being requested by simple string verifications..
-- Spell ID will be simple in adding to the Queue system
-- Spell Name will be slightly more complex.. Possible ideas on how to compare Spell Name against possible Spell choices
---- We can use a predetermined table of Spell ID&amp;apos;s to accept as Spell Name inputs
---- We can scan the entire SpellBook before we even begin and see what spells we know (Run check whenever Spec or Level changes)
---- Still thinking about other methods
-- I may include a Scroll Frame which will display the last X number or Queued Casts and if they were successful or not
if not Nova_Queue_Setup then
local function Event_Reader()

	local function OnEventFunc(self, event, ...)
		if event == &amp;quot;PLAYER_LEVEL_UP&amp;quot; or event == &amp;quot;PLAYER_TALENT_UPDATE&amp;quot; then
			Nova_SpellBookCache = { }
			local _, _, tabOffset, numEntries = GetSpellTabInfo(2) -- The Spell Tab 1 = General Spells, 2 = Current Spec spells
			for i=tabOffset + 1, tabOffset + numEntries do
				local spellName, spellSubName = GetSpellBookItemName(i, &amp;quot;spell&amp;quot;)
				local spell = GetSpellLink(spellName)
				if ( not spellSubName or not string.match(spellSubName, &amp;quot;Passive&amp;quot;) )
				 and spell then
					local SpellNameFinal = string.lower(gsub(spellName, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
					local string1 = gsub(spell, &amp;quot;[%a%|%s%[%]]+&amp;quot;, &amp;quot;&amp;quot;)
					local spellIDfromString = tonumber(string.match(string1, &amp;quot;%p(%d+)&amp;quot;))
					table.insert(Nova_SpellBookCache, { name = SpellNameFinal, id = spellIDfromString } )
				end
			end	
		elseif #Nova_SpellQueueTable &amp;gt; 0 and event == &amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot; then
			if (select(2, ...) == &amp;quot;SPELL_CAST_SUCCESS&amp;quot;
				or select(2, ...) == &amp;quot;SPELL_CAST_START&amp;quot; )
			 and select(4, ...) == UnitGUID(&amp;quot;player&amp;quot;) then			 	
			 	for loop = 1, #Nova_SpellQueueTable do
			 		if Nova_SpellQueueTable[loop].id == select(12, ...) then
			 			table.remove(Nova_SpellQueueTable, loop)
			 			print(&amp;quot;|cff00F0F0Successfully cast|cffFF0000&amp;quot;,select(13, ...),&amp;quot;|cff00F0F0!&amp;quot;)
			 			break
			 		end
			 	end
			end
		end
	end


	local eventReader = CreateFrame(&amp;quot;frame&amp;quot;, nil)
	eventReader:RegisterEvent(&amp;quot;PLAYER_LEVEL_UP&amp;quot;)
	eventReader:RegisterEvent(&amp;quot;PLAYER_TALENT_UPDATE&amp;quot;)
	eventReader:RegisterEvent(&amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot;)
	eventReader:SetScript(&amp;quot;OnEvent&amp;quot;, OnEventFunc)

end

function CheckForValidSpell(string)
	-- We need to figure out if we&amp;apos;re dealing with a SpellID or a Spell Name
	local SpellIDCheck = gsub(string, &amp;quot;[%a%p%s]&amp;quot;, &amp;quot;&amp;quot;)
	local SpellNameCheck = string.lower(gsub(string, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
	
	if type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;number&amp;quot; or type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;string&amp;quot; then
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, 0)
	end
	
	-- First We&amp;apos;ll check the Spell ID as it is a quicker check, and return true if we successfully add
	if string.len(SpellIDCheck) &amp;gt; 0 then
		local SpellID = tonumber(SpellIDCheck)
		for t=1, #Nova_SpellBookCache do
			if SpellID == Nova_SpellBookCache[t].id then
				if #Nova_SpellQueueTable &amp;gt; 0 then
					for j=1, #Nova_SpellQueueTable do
						if Nova_SpellBookCache[t].id == Nova_SpellQueueTable[j].id then
							print(&amp;quot;|cff00F0F0Removing|cffFF0000&amp;quot;, GetSpellInfo(Nova_SpellQueueTable[j].id), &amp;quot;|cff00F0F0from the Spell Queue before it was cast!&amp;quot;)
							table.remove(Nova_SpellQueueTable, j)
							return false
						end
					end
				end
				table.insert(Nova_SpellQueueTable, { name = Nova_SpellBookCache[t].name, id = Nova_SpellBookCache[t].id })
				NovaSpellQueueHistory(Nova_SpellBookCache[t].id)
				print(&amp;quot;|cff00F0F0Successfully added |cffFF0000&amp;quot;..GetSpellInfo(Nova_SpellBookCache[t].id)..&amp;quot;|cff00F0F0 to the Spell Queue&amp;quot;)
				return 
			end
		end
	end

	-- If we had a string that appeared to be an ID we&amp;apos;ll check that first, if nothign returns true, we
	-- will then check the Spell Name and if that is a true Spell
	if string.len(SpellNameCheck) &amp;gt; 0 then
		for k=1, #Nova_SpellBookCache do
			if SpellNameCheck == Nova_SpellBookCache[k].name then
				if #Nova_SpellQueueTable &amp;gt; 0 then
					for j=1, #Nova_SpellQueueTable do
						if Nova_SpellBookCache[k].id == Nova_SpellQueueTable[j].id then	
							print(&amp;quot;|cff00F0F0Removing|cffFF0000&amp;quot;, GetSpellInfo(Nova_SpellQueueTable[j].id), &amp;quot;|cff00F0F0from the Spell Queue before it was cast!&amp;quot;)
							table.remove(Nova_SpellQueueTable, j)
							return false
						end
					end
				end
				table.insert(Nova_SpellQueueTable, { name = Nova_SpellBookCache[k].name, id = Nova_SpellBookCache[k].id })
				NovaSpellQueueHistory(Nova_SpellBookCache[k].id)
				print(&amp;quot;|cff00F0F0Successfully added |cffFF0000&amp;quot;..GetSpellInfo(Nova_SpellBookCache[k].id)..&amp;quot;|cff00F0F0 to the Spell Queue&amp;quot;)
				return 
			end
		end
	else return false
	end
	
	print(&amp;quot;|cffFF00FFThere wasn&amp;apos;t a Spell to go along with what your input&amp;quot;)
	return false
end


function NovaSpellQueueHistory(spellID)
	local buttonID = spellID
	local buttonName = GetSpellInfo(buttonID)
	local AlreadyInHistory = false
	-- We are seeing if it&amp;apos;s already in the Spell Queue History or not
	-- If not, we will create a new button if 6 don&amp;apos;t exists already
	-- Or we will overwrite the oldest Spell in the History
	for h=1, #Nova_SpellQueueHistory do
		if buttonID == Nova_SpellQueueHistory[h].id then
			table.sort(Nova_SpellQueueHistory, function(x) return x.id == spellID end)
			AlreadyInHistory = true
		end
	end
	if not AlreadyInHistory then
		if #Nova_SpellQueueHistory &amp;lt;= 5 then
				local spellButton = CreateFrame(&amp;quot;button&amp;quot;, &amp;quot;SpellQueueSystemButton&amp;quot;..tostring(#Nova_SpellQueueHistory + 1), SpellQueueSystemContent, &amp;quot;UIPanelButtonTemplate&amp;quot;)
				spellButton:SetSize(110, 20)
				spellButton:SetScript(&amp;quot;OnClick&amp;quot;, function(self) 
					SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, self:GetText())
				end)
				table.insert(Nova_SpellQueueHistory, 1, {name=buttonName, id=buttonID, button=spellButton}) 
		elseif #Nova_SpellQueueHistory == 6 then
				Nova_SpellQueueHistory[6].id = buttonID
				Nova_SpellQueueHistory[6].name = buttonName
				table.sort(Nova_SpellQueueHistory, function(x) return x.id == spellID end)
		end
	end
	
	local startPointX, startPointY = 10, 5
	for i=1, #Nova_SpellQueueHistory do
		local ButtonSetting = Nova_SpellQueueHistory[i].button
		ButtonSetting:SetText(Nova_SpellQueueHistory[i].name)
		ButtonSetting:ClearAllPoints()
		if i &amp;lt;= 3 then
			ButtonSetting:SetPoint(&amp;quot;TOPLEFT&amp;quot;, SpellQueueSystemContent, &amp;quot;TOPLEFT&amp;quot;, startPointX, - (startPointY + (24 * (i-1))))
		else
			ButtonSetting:SetPoint(&amp;quot;TOPRIGHT&amp;quot;, SpellQueueSystemContent, &amp;quot;TOPRIGHT&amp;quot;, - startPointX , - (startPointY + (24 * (i-4))))
		end
	end
end

function Nova_Queue_Setup()
	if GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;) == nil then RegisterCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;) end
	Nova_SpellBookCache = { }
	Nova_SpellQueueTable = { }
	Nova_SpellQueueHistory = { }
	local _, _, tabOffset, numEntries = GetSpellTabInfo(2) -- The Spell Tab 1 = General Spells, 2 = Current Spec spells
	for i=tabOffset + 1, tabOffset + numEntries do
		local spellName, spellSubName = GetSpellBookItemName(i, &amp;quot;spell&amp;quot;)
		local spell = GetSpellLink(spellName)
		if ( not spellSubName or not string.match(spellSubName, &amp;quot;Passive&amp;quot;) )
		 and spell then
			local SpellNameFinal = string.lower(gsub(spellName, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
			local string1 = gsub(spell, &amp;quot;[%a%|%s%[%]]+&amp;quot;, &amp;quot;&amp;quot;)
			local spellIDfromString = tonumber(string.match(string1, &amp;quot;%p(%d+)&amp;quot;))
			table.insert(Nova_SpellBookCache, { name = SpellNameFinal, id = spellIDfromString } )
		end
	end	

	-- Title
	local frameTitle = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystemTitle&amp;quot;, UIParent)
	frameTitle:ClearAllPoints()
	frameTitle:SetSize(120, 27)	
	frameTitle:SetMovable(true)
	frameTitle:EnableMouse(true)
	frameTitle:RegisterForDrag(&amp;quot;LeftButton&amp;quot;)
	frameTitle:SetScript(&amp;quot;OnDragStart&amp;quot;, frameTitle.StartMoving)
	frameTitle:SetScript(&amp;quot;OnDragStop&amp;quot;, frameTitle.StopMovingOrSizing)
	frameTitle:SetScript(&amp;quot;OnShow&amp;quot;, RefreshFrameBoxes)
	local TitleString = frameTitle:CreateFontString(&amp;quot;TitleString&amp;quot;)
	TitleString:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
	TitleString:SetText(&amp;quot;Spell Queue System&amp;quot;)
	TitleString:SetJustifyH(&amp;quot;CENTER&amp;quot;)
	TitleString:SetJustifyV(&amp;quot;CENTER&amp;quot;)
	TitleString:ClearAllPoints()
	TitleString:SetPoint(&amp;quot;TOPLEFT&amp;quot;, SpellQueueSystemTitle, &amp;quot;TOPLEFT&amp;quot;)
	TitleString:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, SpellQueueSystemTitle, &amp;quot;BOTTOMRIGHT&amp;quot;)
	frameTitle:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 16, edgeSize = 16, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameTitle:SetBackdropColor(0,0,0,1);
	frameTitle:SetPoint(&amp;quot;CENTER&amp;quot;, -300, 100)
	frameTitle:Hide()
	
	
	-- Main Frame that we shall link everything to
	local frameMain = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystem&amp;quot;, SpellQueueSystemTitle)
	frameMain:ClearAllPoints()
	frameMain:SetSize(260, 115)
	frameMain:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 16, edgeSize = 16, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameMain:SetBackdropColor(0,0,0,1);
	frameMain:SetPoint(&amp;quot;TOP&amp;quot;, SpellQueueSystemTitle, &amp;quot;BOTTOM&amp;quot;, 0, -2)
	frameMain:Show()




	-- Close/Hide Button
	local frameClose = CreateFrame(&amp;apos;Button&amp;apos;, &amp;apos;SpellQueueSystemClose&amp;apos;, frameMain)
	frameClose:ClearAllPoints()
	frameClose:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameMain, &amp;quot;TOPRIGHT&amp;quot;, 0, 4)
	frameClose:RegisterForClicks(&amp;quot;LeftButtonDown&amp;quot;)
	frameClose:SetSize(20, 20)
	local closeText = frameClose:CreateFontString(&amp;quot;closeText&amp;quot;)
	closeText:SetFontObject(&amp;quot;GameTooltipTextSmall&amp;quot;)
	closeText:SetText(&amp;quot;|cFFFFFAFA X|cffffffff&amp;quot;)
	closeText:ClearAllPoints()
	closeText:SetAllPoints(frameClose)
	closeText:SetJustifyH(&amp;quot;CENTER&amp;quot;)
	closeText:SetJustifyV(&amp;quot;CENTER&amp;quot;)
	frameClose:SetScript(&amp;apos;OnClick&amp;apos;, function() frameTitle:Hide() end )
	frameClose:SetBackdrop({ 
									edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
									tile = false, tileSize = 12, edgeSize = 12, 
									insets = { left = 6, right = 6, top = 6, bottom = 6 }
									})
	frameClose:Show()
	
	-- Content Frame
	local frameContent = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystemContent&amp;quot;, frameMain)
	frameContent:ClearAllPoints()
	frameContent:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameMain, &amp;quot;TOPLEFT&amp;quot;, 5, -28)
	frameContent:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameMain, &amp;quot;BOTTOMRIGHT&amp;quot;, -5, 5)
	frameContent:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 8, edgeSize = 8, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameContent:SetBackdropColor(0,0,0,1);
	
	-- EditBox
	local frameEditbox = CreateFrame(&amp;quot;Editbox&amp;quot;, &amp;quot;SpellQueueSystemEditbox&amp;quot;, frameMain, &amp;quot;InputBoxTemplate&amp;quot;)
	frameEditbox:SetSize(180, 18)
	frameEditbox:ClearAllPoints()
	frameEditbox:SetAutoFocus(false)
	frameEditbox:ClearFocus()
	frameEditbox:SetPoint(&amp;quot;BOTTOMLEFT&amp;quot;, frameContent, &amp;quot;TOPLEFT&amp;quot;, 8, 4)
	frameEditbox:SetScript(&amp;quot;OnEnterPressed&amp;quot;, function(self) 
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, self:GetText())
		self:SetText(&amp;quot;&amp;quot;)
		self:ClearFocus() 
	end)
	frameEditbox:SetScript(&amp;quot;OnEscapePressed&amp;quot;, function(self) self:SetText(&amp;quot;&amp;quot;); self:ClearFocus() end)

	-- Accept Button
	local frameAccept = CreateFrame(&amp;quot;Button&amp;quot;, &amp;quot;SpellQueueSystemAccept&amp;quot;, frameEditbox, &amp;quot;UIPanelButtonTemplate&amp;quot;)
	frameAccept:SetBackdrop({edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
							tile = true, tileSize = 8, edgeSize = 8, 
							insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameAccept:SetBackdropBorderColor(1,1,1,1);
	frameAccept:SetNormalFontObject(&amp;quot;GameTooltipText&amp;quot;)
	frameAccept:SetText(&amp;quot;Accept&amp;quot;)
	frameAccept:SetSize(60, 18)
	frameAccept:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameContent, &amp;quot;TOPRIGHT&amp;quot;, 0, 4)
	frameAccept:SetScript(&amp;quot;OnClick&amp;quot;, function() 
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, frameEditbox:GetText())
		frameEditbox:SetText(&amp;quot;&amp;quot;)
		frameEditbox:ClearFocus() 
	end)

	Event_Reader()
	


end
end

SLASH_NOVASPELLQUEUE1 = &amp;quot;/novaspell&amp;quot;
function SlashCmdList.NOVASPELLQUEUE(spellText, editbox)
	if spellText ~= &amp;quot;firstrun&amp;quot; then
		if issecure() then
			SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, spellText)
		else
			print(&amp;quot;Not Secure to use the Slash Commands, use Frame from now on, until you can /console reloadui&amp;quot;)
		end
	end
end

if not Setup then
	Nova_Queue_Setup()
	
	SLASH_NOVASPELLFRAME1 = &amp;quot;/nsq&amp;quot;
	function SlashCmdList.NOVASPELLFRAME(spellText, editbox)
		if not _G.SpellQueueSystemTitle:IsVisible() then
			_G.SpellQueueSystemTitle:Show()
		else
			_G.SpellQueueSystemTitle:Hide()
		end
	end
	
	RunMacroText(&amp;quot;/novaspell firstrun&amp;quot;)
	Setup = true
end

if type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;string&amp;quot; or type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;number&amp;quot; then
	CheckForValidSpell(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;))
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Spell Queue Cast --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if #Nova_SpellQueueTable &amp;gt; 0 then
	for i=1, #Nova_SpellQueueTable do
		spell = Nova_SpellQueueTable[i].id
		if select(2, GetSpellCooldown(spell)) == 0 
		 or ( ( GetSpellCooldown(spell) + select(2, GetSpellCooldown(spell)) - GetTime() ) &amp;lt; 0.5 ) then
			SpellCancelQueuedSpell() -- Blizzard Function, not related to my Frame
			CastSpellByName(GetSpellInfo(spell))
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability></DEATHKNIGHT>